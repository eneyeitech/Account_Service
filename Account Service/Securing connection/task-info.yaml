type: edu
files:
- name: build.gradle
  visible: true
  text: |-
    plugins {
        id 'java'
        id 'org.springframework.boot' version '2.3.1.RELEASE'
        id 'io.spring.dependency-management' version '1.0.9.RELEASE'
    }

    repositories {
        mavenCentral()
    }

    sourceSets.main.resources.srcDirs = ["src/resources"]

    dependencies {
        implementation 'org.springframework.boot:spring-boot-starter'
        implementation 'org.springframework.boot:spring-boot-starter-actuator'
        implementation 'org.springframework.boot:spring-boot-starter-web'
        implementation group: 'org.hibernate', name: 'hibernate-validator', version: '6.1.0.Final'
    }
  learner_created: false
- name: src/account/AccountServiceApplication.java
  visible: true
  text: |-
    package account;

    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;

    @SpringBootApplication
    public class AccountServiceApplication {

        public static void main(String[] args) {
            SpringApplication.run(AccountServiceApplication.class, args);
        }

    }
  learner_created: false
- name: src/resources/application.properties
  visible: true
  text: |-
    server.port=28852
    management.endpoints.web.exposure.include=*
    management.endpoint.shutdown.enabled=true
    spring.jackson.serialization.INDENT_OUTPUT=true
  learner_created: false
- name: test/AccountServiceTest.java
  visible: false
  text: |
    import account.AccountServiceApplication;
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.dynamic.input.DynamicTesting;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.mocks.web.request.HttpRequest;
    import org.hyperskill.hstest.stage.SpringTest;
    import org.hyperskill.hstest.testcase.CheckResult;

    import javax.net.ssl.*;
    import java.security.cert.X509Certificate;

    public class AccountServiceTest extends SpringTest {
      public AccountServiceTest() {
        super(AccountServiceApplication.class, "../service_db.mv.db");
      }

      SSLSocket socket;
      java.security.cert.X509Certificate[] chain;

      // Warning!!! Only for testing reason, trust all certificates!
      TrustManager[] trustAllCerts = new TrustManager[] {
              new X509TrustManager() {
                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                  return new java.security.cert.X509Certificate[0];
                }
                public void checkClientTrusted(
                        java.security.cert.X509Certificate[] certs, String authType) {
                }
                public void checkServerTrusted(
                        java.security.cert.X509Certificate[] certs, String authType) {
                }
              }
      };

      // Test SSL
      public CheckResult checkCertificateName(String nameCN) {
        try {
          SSLContext sc = SSLContext.getInstance("SSL");
          //ТАК нельзя!!! доверяем всем сертификатам, только для тестирования и разработки!!!
          sc.init(null, trustAllCerts, new java.security.SecureRandom());
          SSLSocketFactory factory = sc.getSocketFactory();
          HttpRequest request = get("");
          socket = (SSLSocket) factory.createSocket(request.getHost(), request.getPort());
          getCertificates();
          if (findCert(nameCN)) {
            return CheckResult.correct();
          } else {
            throw new WrongAnswer("Not found certificate with CN - " + nameCN);
          }
        } catch (Exception e) {
          e.printStackTrace();
          System.out.println("Connection not found");
          throw new WrongAnswer("Can't establish https connection!");
        }
      }

      // Get certificate chain
      public void getCertificates() {
        try {
          chain = (X509Certificate[]) socket.getSession().getPeerCertificates();
        } catch (SSLPeerUnverifiedException e) {
          e.printStackTrace();
          System.out.println(e.toString());
        }
      }


      // Searching certificate by Common Name
      public boolean findCert(String subject) {
        for (java.security.cert.X509Certificate c : chain) {
          String subjectName = c.getSubjectDN().getName();
          System.out.println(subjectName + " " + c.getSigAlgName());
          if (subjectName.contains("CN=" + subject)) {
            return true;
          }
        }
        return false;
      }

      @DynamicTest
      DynamicTesting[] dt = new DynamicTesting[]{

              // Check certificate name
              () -> checkCertificateName("accountant_service"),
      };
    }
  learner_created: false
- name: src/account/SqliteDAOFactory.java
  visible: true
  text: |
    package account;

    // Cloudscape concrete DAO Factory implementation
    import org.sqlite.SQLiteDataSource;

    import java.sql.*;

    public class SqliteDAOFactory extends DAOFactory {
        public static final String DRIVER=
                "COM.cloudscape.core.RmiJdbcDriver";
        public static final String DBURL=
                "jdbc:sqlite:C:/db/accounts.db";

        // method to create Cloudscape connections
        public static Connection createConnection() throws SQLException {
            // Use DRIVER and DBURL to create a connection
            // Recommend connection pool implementation/usage
            SQLiteDataSource dataSource = new SQLiteDataSource();
            dataSource.setUrl(DBURL);
            return dataSource.getConnection();
        }

        public PaymentDAO getPaymentDAO() {
            // SqlitePaymentsDAO implements PaymentsDAO
            return new SqlitePaymentDAO();
        }
    }
  learner_created: true
- name: src/account/UserGroupRepository.java
  visible: true
  text: |
    package account;

    import org.springframework.data.repository.CrudRepository;
    import org.springframework.stereotype.Component;

    @Component
    public interface UserGroupRepository extends CrudRepository<Group, Long> {
    }
  learner_created: true
- name: src/account/CustomAccessDeniedHandler.java
  visible: true
  text: |
    package account;

    import org.json.JSONObject;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.security.access.AccessDeniedException;
    import org.springframework.security.core.Authentication;
    import org.springframework.security.core.context.SecurityContextHolder;
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.security.web.access.AccessDeniedHandler;
    import org.springframework.stereotype.Component;

    import javax.servlet.ServletException;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    import java.time.LocalDateTime;
    import java.util.Map;

    @Component
    public class CustomAccessDeniedHandler implements AccessDeniedHandler {

        @Autowired
        EventRepository eventRepo;

        @Override
        public void handle(
                HttpServletRequest request,
                           HttpServletResponse response,
                           AccessDeniedException accessDeniedException
        ) throws IOException, ServletException {

            Authentication auth
                    = SecurityContextHolder.getContext().getAuthentication();
            if (auth != null) {
                User user = ((UserDetailsImpl) auth.getPrincipal()).getUser();

                //Log event
                Event event = new Event();
                String path = request.getRequestURI();
                event.setSubject(user.getEmail().toLowerCase());
                event.setPath(path);
                event.setAction(EventEnum.ACCESS_DENIED.name());
                event.setObject(path);
                eventRepo.save(event);

                response.setContentType("application/json;charset=UTF-8");
                response.setStatus(HttpServletResponse.SC_FORBIDDEN);
                response.getWriter().write(new JSONObject()
                                .put("message", "Access Denied!")
                        .put("timestamp", LocalDateTime.now())
                        .put("error","Forbidden")
                        .put("status", 403)
                        .put("path", request.getRequestURI())
                .toString());

            }
        }
    }
  learner_created: true
- name: src/account/Payment.java
  visible: true
  text: |
    package account;

    public class Payment {
        private String employee;
        private String period;
        private long salary;

        public String getEmployee() {
            return employee;
        }

        public void setEmployee(String employee) {
            this.employee = employee;
        }

        public String getPeriod() {
            return period;
        }

        public void setPeriod(String period) {
            this.period = period;
        }

        public long getSalary() {
            return salary;
        }

        public void setSalary(long salary) {
            this.salary = salary;
        }

        @Override
        public String toString() {
            return "Payment{" +
                    "employee='" + employee + '\'' +
                    ", period='" + period + '\'' +
                    ", salary=" + salary +
                    '}';
        }
    }
  learner_created: true
- name: src/account/LoginAttemptService.java
  visible: true
  text: |
    package account;

    import com.google.common.cache.CacheBuilder;
    import com.google.common.cache.CacheLoader;
    import com.google.common.cache.LoadingCache;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.security.core.context.SecurityContextHolder;
    import org.springframework.stereotype.Service;

    import javax.servlet.http.HttpServletRequest;
    import java.util.concurrent.ExecutionException;
    import java.util.concurrent.TimeUnit;

    @Service
    public class LoginAttemptService {

        @Autowired
        private HttpServletRequest request;

        @Autowired
        EventRepository eventRepo;

        private final int MAX_ATTEMPT = 5;
        private LoadingCache<String, Integer> attemptsCache;


        public LoginAttemptService() {
            super();
            attemptsCache = CacheBuilder.newBuilder().
                    expireAfterWrite(1, TimeUnit.DAYS).build(new CacheLoader<String, Integer>() {
                        public Integer load(String key) {
                            return 0;
                        }
                    });
        }

        public void loginSucceeded(String key) {
            //attemptsCache.invalidate(key);
            reset(key);
        }

        public void reset(String key) {
            attemptsCache.invalidate(key);
        }

        public void loginFailed(String key) {
            int attempts = 0;
            try {
                attempts = attemptsCache.get(key);
            } catch (ExecutionException e) {
                attempts = 0;
            }
            attempts++;
            attemptsCache.put(key, attempts);
        }

        public boolean isBlocked(String key) {
            try {
                return attemptsCache.get(key) >= MAX_ATTEMPT;
            } catch (ExecutionException e) {
                return false;
            }
        }
    }
  learner_created: true
- name: src/account/Handler.java
  visible: true
  text: |
    package account;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.security.access.AccessDeniedException;
    import org.springframework.security.core.Authentication;
    import org.springframework.security.core.AuthenticationException;
    import org.springframework.security.core.context.SecurityContextHolder;
    import org.springframework.web.HttpRequestMethodNotSupportedException;
    import org.springframework.web.bind.MethodArgumentNotValidException;
    import org.springframework.web.bind.annotation.ControllerAdvice;
    import org.springframework.web.bind.annotation.ExceptionHandler;

    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import javax.validation.ConstraintViolationException;
    import java.util.Map;

    @ControllerAdvice
    public class Handler {

        @Autowired
        EventRepository eventRepo;

        @ExceptionHandler(Exception.class)
        public ResponseEntity<Object> handle(Exception ex,
                                             HttpServletRequest request, HttpServletResponse response) {

            if (ex instanceof NullPointerException) {
                return new ResponseEntity<>(Map.of("message", "1Bad Request", "error","Bad Request","status", 400), HttpStatus.BAD_REQUEST);
            }

            if (ex instanceof HttpRequestMethodNotSupportedException) {

                //logger
                Authentication auth
                        = SecurityContextHolder.getContext().getAuthentication();
                if (auth != null) {
                    User user = ((UserDetailsImpl) auth.getPrincipal()).getUser();

                    //Log event
                    Event event = new Event();
                    String path = request.getRequestURI();
                    event.setSubject(user.getEmail().toLowerCase());
                    event.setPath(path);
                    event.setAction(EventEnum.ACCESS_DENIED.name());
                    event.setObject(path);
                    eventRepo.save(event);
                }
                //endlogger

                return new ResponseEntity<>(Map.of(
                        "message", "Access Denied!",
                        "error","Forbidden",
                        "status", 403,
                        "path", request.getRequestURI()
                ), HttpStatus.FORBIDDEN);
            }

            if (ex instanceof AccessDeniedException) {
                return new ResponseEntity<>(Map.of(
                        "message", "Access Denied!",
                        "error","Forbidden",
                        "status", 403,
                        "path", "/api/admin/user/role"
                ), HttpStatus.FORBIDDEN);
            }

            if (ex instanceof AuthenticationException) {
                return new ResponseEntity<>(Map.of(
                        "message", "Access Denied!",
                        "error","Forbidden",
                        "status", 403,
                        "path", "/api/admin/user/role"
                ), HttpStatus.FORBIDDEN);
            }

            if (ex instanceof ConstraintViolationException) {
                return new ResponseEntity<>(Map.of("message", "3Bad Request", "error","Bad Request","status", 400), HttpStatus.BAD_REQUEST);
            }

            if (ex instanceof MethodArgumentNotValidException) {
                return new ResponseEntity<>(Map.of("message", "5Bad Request", "error","Bad Request","status", 400), HttpStatus.BAD_REQUEST);
            }

            return new ResponseEntity<>(Map.of("message", "Password length must be 12 chars minimum!",
                    "error","Bad Request",
                    "status", 400,
            "path", "/api/auth/changepass"), HttpStatus.BAD_REQUEST);
        }
    }
  learner_created: true
- name: src/account/UsersRepository.java
  visible: true
  text: |
    package account;

    import org.springframework.data.repository.CrudRepository;
    import org.springframework.stereotype.Component;

    @Component
    public interface UsersRepository extends CrudRepository<User, Long> {
    }
  learner_created: true
- name: src/account/UserDetailsServiceImpl.java
  visible: true
  text: |+
    package account;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.security.core.userdetails.UserDetailsService;
    import org.springframework.security.core.userdetails.UsernameNotFoundException;
    import org.springframework.stereotype.Service;

    import javax.servlet.http.HttpServletRequest;
    import javax.transaction.Transactional;

    @Service
    public class UserDetailsServiceImpl implements UserDetailsService {
        @Autowired
        UserRepository userRepo;

        @Autowired
        private LoginAttemptService loginAttemptService;

        @Autowired
        private HttpServletRequest request;

        @Override
        public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
            String ip = getClientIP();
            if (loginAttemptService.isBlocked(email)) {
                throw new RuntimeException("User account is locked");
            }

            User user = userRepo.findUserByEmail(email);

            if (user == null) {
                throw new UsernameNotFoundException("Not found: " + email);
            }

            return new UserDetailsImpl(user);
        }

        //added
        private String getClientIP() {
            String xfHeader = request.getHeader("X-Forwarded-For");
            if (xfHeader == null){
                return request.getRemoteAddr();
            }
            return xfHeader.split(",")[0];
        }
    }

  learner_created: true
- name: src/account/GroupRepository.java
  visible: true
  text: |
    package account;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Component;

    import java.util.ArrayList;
    import java.util.List;
    import java.util.Optional;

    @Component
    public class GroupRepository {
        @Autowired
        UserGroupRepository repository;

        public Group findByCode(String code) {
            System.out.println(code);
            List<Group> list = new ArrayList<>();
            repository.findAll().forEach(g -> list.add(g));
            System.out.println("size");
            Optional<Group> matchingGroup = list.stream().
                    filter(g -> g.getCode().equalsIgnoreCase(code)).
                    findFirst();
            Group group = null;
            System.out.println(group);
            if (matchingGroup.isPresent()){
                group = matchingGroup.get();
            }
            System.out.println(group);
            return group;
        }

        public void save(Group group) {
            Group savedGroup = repository.save(group);
            System.out.println(savedGroup + " saved.");
        }

        public boolean hasCode(String code) {
            List<Group> list = new ArrayList<>();
            repository.findAll().forEach(g -> list.add(g));
            Optional<Group> matchingGroup = list.stream().
                    filter(g -> g.getCode().equalsIgnoreCase(code)).
                    findFirst();
            return matchingGroup.isPresent();
        }
    }
  learner_created: true
- name: src/account/H2PaymentDAO.java
  visible: true
  text: |
    package account;

    import javax.sql.RowSet;
    import java.util.ArrayList;
    import java.util.Collection;
    import java.util.Date;

    public class H2PaymentDAO implements PaymentDAO{

        @Override
        public int insertPayment(Payment payment) {
            return 0;
        }

        @Override
        public int insertPayments(Collection<Payment> payments) {
            return 0;
        }

        @Override
        public int updatePayment(Payment payment) {
            return 0;
        }

        @Override
        public RowSet selectPaymentsRS(String email) {
            return null;
        }

        @Override
        public ArrayList selectPaymentsTO(String email) {
            return null;
        }

        @Override
        public RowSet selectPaymentsForRS(String email, String date) {
            return null;
        }

        @Override
        public ArrayList selectPaymentsForTO(String email, String date) {
            return null;
        }
    }
  learner_created: true
- name: src/account/AuthenticationController.java
  visible: true
  text: |
    package account;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.security.core.annotation.AuthenticationPrincipal;
    import org.springframework.security.crypto.password.PasswordEncoder;
    import org.springframework.web.bind.annotation.PostMapping;
    import org.springframework.web.bind.annotation.RequestBody;
    import org.springframework.web.bind.annotation.RestController;
    import org.springframework.web.server.ResponseStatusException;

    import javax.validation.Valid;
    import java.util.*;

    @RestController
    public class AuthenticationController {

        private Store store;
        private long id = 0L;
        private List<String> breachedPassword;

        {
            breachedPassword = new ArrayList<>(List.of("PasswordForJanuary", "PasswordForFebruary", "PasswordForMarch", "PasswordForApril",
                    "PasswordForMay", "PasswordForJune", "PasswordForJuly", "PasswordForAugust",
                    "PasswordForSeptember", "PasswordForOctober", "PasswordForNovember", "PasswordForDecember"));
        }

        @Autowired
        UserRepository userRepo;

        @Autowired
        BCryptEncoderConfig b;

        @Autowired
        EventRepository eventRepo;

        @Autowired
        public AuthenticationController(Store store) {
            this.store = store;
        }

        @PostMapping("api/auth/signup")
        public ResponseEntity<Map<String, Object>> signUp(@Valid @RequestBody User user) {
            if (user.getEmail().isBlank() || user.getEmail().equals("") || user.getEmail().isEmpty()){
                //throw new ResponseStatusException(HttpStatus.BAD_REQUEST);
                return new ResponseEntity<>(Map.of("error", "email empty"), HttpStatus.BAD_REQUEST);
            }
            if (!user.getEmail().matches("\\w+(@acme.com)$")){
                return new ResponseEntity<>(Map.of("error", "email incorrect"), HttpStatus.BAD_REQUEST);
            }
            if (user.getLastname().isBlank() || user.getLastname().equals("") || user.getLastname().isEmpty()){
                return new ResponseEntity<>(Map.of("error", "lastname not valid"), HttpStatus.BAD_REQUEST);
            }
            if (user.getPassword().isBlank() || user.getPassword().equals("") || user.getPassword().isEmpty() ){
                return new ResponseEntity<>(Map.of("error", "password not valid"), HttpStatus.BAD_REQUEST);
            }
            if (breachedPassword.contains(user.getPassword())) {
                return new ResponseEntity<>(Map.of("message", "The password is in the hacker's database!",
                        "error","Bad Request",
                        "status", 400,
                        "path", "/api/auth/signup"), HttpStatus.BAD_REQUEST);
            }
            if (user.getName().isBlank() || user.getName().equals("") || user.getName().isEmpty()){
                return new ResponseEntity<>(Map.of("error", "name not valid"), HttpStatus.BAD_REQUEST);
            }
            //return new ResponseEntity<>(user, HttpStatus.OK);
            //store.getUserStore().put(user.getEmail(), user);
            //id++;
            user.setPassword(b.getEncoder().encode(user.getPassword()));
            //user.setId(id);
            if (userRepo.hasUser(user)) {
                return new ResponseEntity<>(Map.of("message", "User exist!", "error","Bad Request","status", 400), HttpStatus.BAD_REQUEST);
            }else{
                user.setLocked(false);
                userRepo.save(user);

                //Log event
                Event event = new Event();
                String path = "/api/auth/signup";
                event.setSubject("Anonymous");
                event.setPath(path);
                event.setAction(EventEnum.CREATE_USER.name());
                event.setObject(user.getEmail().toLowerCase());
                eventRepo.save(event);
            }

            Set<Group> groups = user.getUserGroups();
            Set<String> roles = new TreeSet<>();
            for (Group g: groups) {
                roles.add(g.getCode());
            }

            return new ResponseEntity<>(Map.of("id", user.getId(),
                    "name", user.getName(),
                    "lastname", user.getLastname(),
                    "email", user.getEmail(), "roles", roles), HttpStatus.OK);
        }

        @PostMapping("api/auth/changepass")
        public ResponseEntity<Object> changePassword(@AuthenticationPrincipal UserDetailsImpl details, @Valid @RequestBody Password password) {
            if (details == null) {
                return new ResponseEntity<>(Map.of("error", "email not valid"), HttpStatus.BAD_REQUEST);
            } else {
                if (breachedPassword.contains(password.getNew_password())) {
                    return new ResponseEntity<>(Map.of("message", "The password is in the hacker's database!", "error","Bad Request","status", 400), HttpStatus.BAD_REQUEST);
                }

                User user = details.getUser();

                if (b.getEncoder().matches(password.getNew_password(), user.getPassword())) {
                    return new ResponseEntity<>(Map.of("message", "The passwords must be different!",
                            "error","Bad Request",
                            "status", 400,
                            "path", "/api/auth/changepass"), HttpStatus.BAD_REQUEST);
                }

                user.setPassword(b.getEncoder().encode(password.getNew_password()));
                userRepo.updatePassword(user);
                Event event = new Event();
                String path = "/api/auth/changepass";
                event.setSubject(user.getEmail().toLowerCase());
                event.setPath(path);
                event.setAction(EventEnum.CHANGE_PASSWORD.name());
                event.setObject(user.getEmail().toLowerCase());
                eventRepo.save(event);
                return new ResponseEntity<>(Map.of("email", user.getEmail(), "status", "The password has been updated successfully"), HttpStatus.OK);
            }
        }
    }
  learner_created: true
- name: src/account/ServiceController.java
  visible: true
  text: |
    package account;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.security.core.annotation.AuthenticationPrincipal;
    import org.springframework.web.bind.annotation.*;

    import javax.validation.Valid;
    import java.util.*;

    @RestController
    public class ServiceController {

        private Store store;
        @Autowired
        UserRepository userRepo;

        @Autowired
        LockedAccounts lockedAccounts;

        @Autowired
        LoginAttemptService loginAttemptService;

        @Autowired
        GroupRepository groupRepo;

        @Autowired
        EventRepository eventRepo;

        @Autowired
        public ServiceController(Store store) {
            this.store = store;
        }

        @PutMapping("api/admin/user/role")
        public Object changeUserRole(@AuthenticationPrincipal UserDetailsImpl details, @Valid @RequestBody Role role) {
            if (details == null) {
                return new ResponseEntity<>(Map.of("error", "email not valid"), HttpStatus.BAD_REQUEST);
            } else {
                String roleString = "ROLE_"+role.getRole().toUpperCase();
                if (!groupRepo.hasCode(roleString)) {
                    return new ResponseEntity<>(Map.of("error", "Not Found",
                            "message", "Role not found!",
                            "path", "/api/admin/user/role",
                            "status", 404), HttpStatus.NOT_FOUND);
                }

                User user = details.getUser();

                User userToModify = userRepo.findUserByEmail(role.getUser());
                if (userToModify == null) {
                    return new ResponseEntity<>(Map.of("error", "Not Found",
                            "message", "User not found!",
                            "path", "/api/admin/user/role",
                            "status", 404), HttpStatus.NOT_FOUND);
                }

                Set<Group> groups = userToModify.getUserGroups();
                Set<String> roles = new TreeSet<>();
                for (Group g: groups) {
                    roles.add(g.getCode());
                }

                System.out.println("1="+roleString+" ");
                boolean foundRole = roles.contains(roleString);

                switch (role.getOperation().toLowerCase(Locale.ROOT)) {
                    case "grant":
                        if (foundRole) {
                            return new ResponseEntity<>(Map.of("error", "Bad Request",
                                    "message", "Role already exist!",
                                    "path", "/api/admin/user/role",
                                    "status", 400), HttpStatus.BAD_REQUEST);
                        }
                        if (user.getEmail().equalsIgnoreCase(role.getUser())) {
                            return new ResponseEntity<>(Map.of("error", "Bad Request",
                                    "message", "The user cannot combine administrative and business roles!",
                                    "path", "/api/admin/user/role",
                                    "status", 400), HttpStatus.BAD_REQUEST);
                        }
                        if (roleString.equalsIgnoreCase("role_administrator")) {
                            return new ResponseEntity<>(Map.of("error", "Bad Request",
                                    "message", "The user cannot combine administrative and business roles!",
                                    "path", "/api/admin/user/role",
                                    "status", 400), HttpStatus.BAD_REQUEST);
                        }

                        roles.add(roleString);
                        userToModify.addUserGroups(groupRepo.findByCode(roleString));
                        Event event = new Event();
                        String path = "/api/admin/user/role";
                        event.setSubject(user.getEmail().toLowerCase());
                        event.setPath(path);
                        event.setAction(EventEnum.GRANT_ROLE.name());
                        event.setObject("Grant role "+role.getRole() +" to "+userToModify.getEmail().toLowerCase());
                        eventRepo.save(event);
                        break;
                    case "remove":
                        if (!foundRole) {
                            return new ResponseEntity<>(Map.of("error", "Bad Request",
                                    "message", "The user does not have a role!",
                                    "path", "/api/admin/user/role",
                                    "status", 400), HttpStatus.BAD_REQUEST);
                        }
                        if (roles.size() == 0) {
                            return new ResponseEntity<>(Map.of("error", "Bad Request",
                                    "message", "The user does not have a role!",
                                    "path", "/api/admin/user/role",
                                    "status", 400), HttpStatus.BAD_REQUEST);
                        }
                        if (user.getEmail().equalsIgnoreCase(role.getUser())) {
                            return new ResponseEntity<>(Map.of("error", "Bad Request",
                                    "message", "Can't remove ADMINISTRATOR role!",
                                    "path", "/api/admin/user/role",
                                    "status", 400), HttpStatus.BAD_REQUEST);
                        }
                        if (roles.size() == 1) {
                            return new ResponseEntity<>(Map.of("error", "Bad Request",
                                    "message", "The user must have at least one role!",
                                    "path", "/api/admin/user/role",
                                    "status", 400), HttpStatus.BAD_REQUEST);
                        }
                        roles.remove(roleString);
                        userToModify.removeUserGroups(groupRepo.findByCode(roleString));
                        Event event1 = new Event();
                        String path1 = "/api/admin/user/role";
                        event1.setSubject(user.getEmail().toLowerCase());
                        event1.setPath(path1);
                        event1.setAction(EventEnum.REMOVE_ROLE.name());
                        event1.setObject("Remove role "+role.getRole() +" from "+userToModify.getEmail().toLowerCase());
                        eventRepo.save(event1);
                        break;
                    default:
                }

                User user1 = userRepo.updateRole(userToModify);
                if (user1 == null) {

                }
                Set<Group> groups1 = user1.getUserGroups();
                Set<String> roles1 = new TreeSet<>();
                for (Group g: groups1) {
                    roles1.add(g.getCode());
                }

                return new ResponseEntity<>(Map.of("id", user1.getId(),
                        "name", user1.getName(),
                        "lastname", user1.getLastname(),
                        "email", user1.getEmail().toLowerCase(),
                        "roles", roles), HttpStatus.OK);
            }
        }

        @PutMapping("api/admin/user/access")
        public Object lockUnlockUser(@AuthenticationPrincipal UserDetailsImpl details, @Valid @RequestBody Key key) {
            String path = "/api/admin/user/access";
            String userEmail = key.getUser();
            Event event = new Event();
            event.setPath(path);
            //event.setAction(operation.toUpperCase(Locale.ROOT));


            if (details == null) {
                return new ResponseEntity<>(Map.of("error", "email not valid"), HttpStatus.BAD_REQUEST);
            } else {
                User user = details.getUser();
                event.setSubject(user.getEmail().toLowerCase());
                User userToModify = userRepo.findUserByEmail(key.getUser());
                if (userToModify == null) {
                    return new ResponseEntity<>(Map.of("error", "Not Found",
                            "message", "User not found!",
                            "path", "/api/admin/user/access",
                            "status", 404), HttpStatus.NOT_FOUND);
                }

                switch (key.getOperation().toLowerCase(Locale.ROOT)) {
                    case "lock":
                        if (user.getEmail().equalsIgnoreCase(key.getUser())) {
                            return new ResponseEntity<>(Map.of("error", "Bad Request",
                                    "message", "Can't lock the ADMINISTRATOR!",
                                    "path", "/api/admin/user/access",
                                    "status", 400), HttpStatus.BAD_REQUEST);
                        }

                        event.setAction(EventEnum.LOCK_USER.name());
                        event.setObject("Lock user "+userEmail.toLowerCase());
                        eventRepo.save(event);
                        userToModify.setLocked(true);
                        User userLocked = userRepo.update(userToModify);
                        lockedAccounts.lockUser(userLocked.getEmail());//lock
                        return new ResponseEntity<>(Map.of(
                                "status", "User "+key.getUser().toLowerCase()+" locked!"
                        ), HttpStatus.OK);
                    case "unlock":

                        event.setAction(EventEnum.UNLOCK_USER.name());
                        event.setObject("Unlock user "+userEmail.toLowerCase());
                        eventRepo.save(event);
                        loginAttemptService.reset(userEmail.toLowerCase());
                        userToModify.setLocked(false);
                        User userUnLocked = userRepo.update(userToModify);
                        lockedAccounts.unLockUser(userUnLocked.getEmail());//unlock
                        return new ResponseEntity<>(Map.of(
                                "status", "User "+key.getUser().toLowerCase()+" unlocked!"
                        ), HttpStatus.OK);
                    default:
                }

                return new ResponseEntity<>(Map.of("error", "Bad Request",
                        "message", "Operation not supported!",
                        "path", "/api/admin/user/access",
                        "status", 400), HttpStatus.BAD_REQUEST);



            }
        }

        @DeleteMapping("api/admin/user/{email}")
        public Object deleteUser(@AuthenticationPrincipal UserDetailsImpl details, @PathVariable String email) {
            if (details == null) {
                return new ResponseEntity<>(Map.of("error", "email not valid"), HttpStatus.BAD_REQUEST);
            } else {
                User user = details.getUser();
                if (user.getEmail().equalsIgnoreCase(email)) {
                    return new ResponseEntity<>(Map.of("error", "Bad Request",
                            "message", "Can't remove ADMINISTRATOR role!",
                            "path", "/api/admin/user/"+email,
                            "status", 400), HttpStatus.BAD_REQUEST);
                }
                User userToDelete = userRepo.findUserByEmail(email);
                if (userToDelete == null) {
                    return new ResponseEntity<>(Map.of("error", "Not Found",
                            "message", "User not found!",
                            "path", "/api/admin/user/"+email,
                            "status", 404), HttpStatus.NOT_FOUND);
                }
                userRepo.delete(userToDelete);

                Event event = new Event();
                String path = "/api/admin/user";
                event.setSubject(user.getEmail().toLowerCase());
                event.setPath(path);
                event.setAction(EventEnum.DELETE_USER.name());
                event.setObject(userToDelete.getEmail().toLowerCase());
                eventRepo.save(event);
                return new ResponseEntity<>(Map.of("user", email,
                        "status", "Deleted successfully!"), HttpStatus.OK);
            }
        }

        @GetMapping("api/admin/user")
        public Object getUsers() {
            //return store.getUserStore();
            List<Object> users = new ArrayList<>();
            List<User> userList = (List<User>) userRepo.getUsers();
            for (User user: userList) {
                Set<Group> groups = user.getUserGroups();
                Set<String> roles = new TreeSet<>();
                for (Group g: groups) {
                    roles.add(g.getCode());
                }
                if (roles.contains("ROLE_ADMINISTRATOR")) {
                    //continue;
                }
                users.add(Map.of("id", user.getId(),
                        "name", user.getName(),
                        "lastname", user.getLastname(),
                        "email", user.getEmail().toLowerCase(),
                        "roles", roles));
            }
            //return userRepo.getUsers();
            return new ResponseEntity<>(users, HttpStatus.OK);
        }

        @GetMapping("api/security/events")
        public Object getEvents() {
            return eventRepo.getEvents();
        }
    }
  learner_created: true
- name: src/account/EventIRepository.java
  visible: true
  text: |
    package account;

    import org.springframework.data.repository.CrudRepository;
    import org.springframework.stereotype.Component;

    @Component
    public interface EventIRepository extends CrudRepository<Event, Long> {
    }
  learner_created: true
- name: src/account/LockedAccounts.java
  visible: true
  text: |
    package account;

    import org.springframework.stereotype.Component;

    import java.util.Map;
    import java.util.concurrent.ConcurrentHashMap;

    @Component
    public class LockedAccounts {

        final private Map<String, String> accounts = new ConcurrentHashMap<>();

        public void lockUser(String email) {
            accounts.put(email.toLowerCase(), email);
        }

        public void unLockUser(String email) {
            accounts.remove(email.toLowerCase());
        }

        public boolean isLocked(String email) {
            return accounts.containsKey(email.toLowerCase());
        }
    }
  learner_created: true
- name: src/account/SqlitePaymentDAO.java
  visible: true
  text: |
    package account;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.data.repository.CrudRepository;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.stereotype.Component;

    import javax.sql.RowSet;
    import java.sql.*;
    import java.util.*;
    import java.util.Date;

    @Component
    public class SqlitePaymentDAO implements PaymentDAO {

        @Autowired
        UserRepository userRepo;

        public SqlitePaymentDAO(){

        }

        @Override
        public int insertPayment(Payment payment) {
            String insertPaymentSQL = "INSERT INTO \"payment\" " +
                    "(employee, period, salary) VALUES (?, ?, ?)";

            try (Connection con = SqliteDAOFactory.createConnection()) {

                try (PreparedStatement insertPayment = con.prepareStatement(insertPaymentSQL);) {

                        // Insert a payment
                        insertPayment.setString(1, payment.getEmployee());
                        insertPayment.setString(2, payment.getPeriod());
                        insertPayment.setLong(3, payment.getSalary());
                        insertPayment.executeUpdate();
                        System.out.println(payment + " saved");

                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
            return 1;
        }

        @Override
        public int insertPayments(Collection<Payment> payments) {
            int i = 1;
            String insertPaymentSQL = "INSERT INTO \"payment\" " +
                    "(employee, period, salary) VALUES (?, ?, ?)";

            try (Connection con = SqliteDAOFactory.createConnection()) {

                // Disable auto-commit mode
                con.setAutoCommit(false);

                try (PreparedStatement insertPayment = con.prepareStatement(insertPaymentSQL);) {

                    // Create a savepoint
                    Savepoint savepoint = con.setSavepoint();

                    Iterator iterator = payments.iterator();
                    String tempDate = "";
                    while (iterator.hasNext()) {
                        Payment p = (Payment) iterator.next();
                        // Insert a payment
                        insertPayment.setString(1, p.getEmployee());
                        insertPayment.setString(2, p.getPeriod());
                        insertPayment.setLong(3, p.getSalary());
                        insertPayment.executeUpdate();

                        if (!userRepo.hasUser(p.getEmployee())) {
                            i = 4;
                            con.rollback(savepoint);
                        }

                        if (p.getSalary() < 0) {
                            i = 2;
                            con.rollback(savepoint);
                        }

                        if (tempDate.equalsIgnoreCase(p.getPeriod())) {
                            i = 3;
                            con.rollback(savepoint);
                        }

                        if (!p.getPeriod().matches("(0[1-9]|1[0-2])-20[0-9]{2}$")){
                            i = 5;
                            con.rollback(savepoint);
                        }

                        tempDate = p.getPeriod();

                    }



                    con.commit();
                } catch (SQLException e) {
                    if (con != null) {
                        try {
                            System.err.print("Transaction is being rolled back");
                            con.rollback();
                        } catch (SQLException excep) {
                            excep.printStackTrace();
                        }
                    }
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        return i;
        }

        @Override
        public int updatePayment(Payment payment) {
            String updatePaymentSQL = "UPDATE \"payment\" " +
                    "SET SALARY = ? WHERE EMPLOYEE = ? AND PERIOD = ?";

            try (Connection con = SqliteDAOFactory.createConnection()) {

                try (PreparedStatement insertPayment = con.prepareStatement(updatePaymentSQL);) {

                    // Insert a payment
                    insertPayment.setLong(1, payment.getSalary());
                    insertPayment.setString(2, payment.getEmployee());
                    insertPayment.setString(3, payment.getPeriod());
                    insertPayment.executeUpdate();
                    System.out.println(payment + " updated");

                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
            return 1;
        }

        @Override
        public RowSet selectPaymentsRS(String email) {
            return null;
        }

        @Override
        public ArrayList selectPaymentsTO(String email) {
            ArrayList<Payment> payments = new ArrayList<>();

            String updatePaymentSQL = "SELECT * FROM \"payment\" " +
                    "WHERE EMPLOYEE = ? ORDER BY PERIOD DESC";

            try (Connection con = SqliteDAOFactory.createConnection()) {

                try (PreparedStatement insertPayment = con.prepareStatement(updatePaymentSQL);) {
                    System.out.println("1 query successful " + email);
                    // Insert a payment
                    insertPayment.setString(1, email);
                    ResultSet rs = insertPayment.executeQuery();
                    while (rs.next()) {
                        Payment p = new Payment();
                        p.setEmployee(rs.getString(2));
                        p.setPeriod(rs.getString(3));
                        p.setSalary(rs.getLong(4));
                        payments.add(p);
                    }
                    System.out.println(" query successful");

                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
            return payments;
        }

        @Override
        public RowSet selectPaymentsForRS(String email, String date) {
            return null;
        }

        @Override
        public ArrayList selectPaymentsForTO(String email, String date) {
            ArrayList<Payment> payments = new ArrayList<>();

            String updatePaymentSQL = "SELECT * FROM \"payment\" " +
                    "WHERE EMPLOYEE = ? AND PERIOD = ? ORDER BY PERIOD DESC";

            try (Connection con = SqliteDAOFactory.createConnection()) {

                try (PreparedStatement insertPayment = con.prepareStatement(updatePaymentSQL);) {
                    System.out.println("2 query successful " + email);
                    // Insert a payment
                    insertPayment.setString(1, email);
                    insertPayment.setString(2, date);
                    ResultSet rs = insertPayment.executeQuery();
                    while (rs.next()) {
                        Payment p = new Payment();
                        p.setEmployee(rs.getString(2));
                        p.setPeriod(rs.getString(3));
                        p.setSalary(rs.getLong(4));
                        payments.add(p);
                    }
                    System.out.println(" query successful");

                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
            return payments;
        }
    }
  learner_created: true
- name: src/account/Store.java
  visible: true
  text: |+
    package account;

    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;

    import java.util.Map;
    import java.util.concurrent.ConcurrentHashMap;

    @Configuration
    public class Store {
        private Map<String, User> userStore;

        {
            userStore = new ConcurrentHashMap<>();
            User user1 = new User("name1","lastname1", "email1@acme.com", "xxx1");
            userStore.put(user1.getEmail(), user1);
            User user2 = new User("name2","lastname2", "email2@acme.com", "xxx2");
            userStore.put(user2.getEmail(), user2);
        }

        @Bean
        public Map<String, User> getUserStore() {
            return userStore;
        }

    }

  learner_created: true
- name: src/account/RestAuthenticationEntryPoint.java
  visible: true
  text: |
    package account;

    import com.fasterxml.jackson.databind.util.JSONPObject;
    import org.springframework.security.core.AuthenticationException;
    import org.springframework.security.web.AuthenticationEntryPoint;
    import org.springframework.stereotype.Component;

    import javax.servlet.ServletException;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    import java.time.LocalDateTime;
    import java.util.Map;

    @Component
    public class RestAuthenticationEntryPoint implements AuthenticationEntryPoint {

        @Override
        public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
            //System.out.println("Exception == "+authException);
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, authException.getMessage());
            /**
            response.setContentType("application/json;charset=UTF-8");
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            response.getWriter().write(Map.of(
                    "message", "Access denied!",
                    "timestamp", LocalDateTime.now(),
                    "error","Forbidden",
                    "status", 403

            ).toString());
             */
        }
    }
  learner_created: true
- name: src/account/DAOFactory.java
  visible: true
  text: |
    package account;

    // Abstract class DAO Factory
    public abstract class DAOFactory {

        // List of DAO types supported by the factory
        public static final int  H2 = 1;
        public static final int SQLITE = 2;

        // There will be a method for each DAO that can be
        // created. The concrete factories will have to
        // implement these methods.
        public abstract PaymentDAO getPaymentDAO();

        public static DAOFactory getDAOFactory(
                int whichFactory) {

            switch (whichFactory) {
                case H2:
                    return new H2DAOFactory();
                case SQLITE    :
                    return new SqliteDAOFactory();
                default           :
                    return null;
            }
        }
    }
  learner_created: true
- name: src/account/WebSecurityConfigurerImpl.java
  visible: true
  text: |+
    package account;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.http.HttpMethod;
    import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
    import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
    import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
    import org.springframework.security.config.http.SessionCreationPolicy;
    import org.springframework.security.core.userdetails.UserDetailsService;
    import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
    import org.springframework.security.crypto.password.NoOpPasswordEncoder;
    import org.springframework.security.crypto.password.PasswordEncoder;

    // Extending the adapter and adding the annotation
    @Configuration
    @EnableWebSecurity
    public class WebSecurityConfigurerImpl extends WebSecurityConfigurerAdapter {

        @Autowired
        UserDetailsService userDetailsService;

        @Autowired
        BCryptEncoderConfig b;

        @Autowired
        CustomAccessDeniedHandler customAccessDeniedHandler;

        @Autowired
        RestAuthenticationEntryPoint restAuthenticationEntryPoint;

        // Acquiring the builder
        @Override
        protected void configure(AuthenticationManagerBuilder auth) throws Exception {

            auth
                    .userDetailsService(userDetailsService) // user store 1
                    .passwordEncoder(b.getEncoder());
            auth
                    .inMemoryAuthentication() // user store 2
                    .withUser("Admin").password("hardcoded").roles("USER")
                    .and().passwordEncoder(NoOpPasswordEncoder.getInstance());
        }

        // creating a PasswordEncoder that is needed in two places


       /** @Override
        protected void configure(HttpSecurity http) throws Exception {
            http.authorizeRequests()
                    .mvcMatchers(HttpMethod.POST,"/api/auth/signup").permitAll()
                    .mvcMatchers("/api/empl/payment").authenticated()
                    .and().httpBasic()
                    .and()
                    .csrf().disable();
        }*/

       public void configure(HttpSecurity http) throws Exception {
           http.httpBasic()
                   .authenticationEntryPoint(restAuthenticationEntryPoint) // Handle auth error
                   .and()
                   .csrf().disable().headers().frameOptions().disable() // for Postman, the H2 console
                   .and()
                   .authorizeRequests() // manage access
                   .mvcMatchers(HttpMethod.POST, "/api/auth/signup").permitAll()
                   .mvcMatchers(HttpMethod.POST, "/api/auth/changepass").authenticated()
                   .mvcMatchers(HttpMethod.GET, "/api/empl/payment").hasAnyRole("ACCOUNTANT", "USER")
                   .mvcMatchers(HttpMethod.POST, "/api/acct/payments").hasRole("ACCOUNTANT")
                   .mvcMatchers(HttpMethod.PUT, "/api/acct/payments").hasRole("ACCOUNTANT")
                   .mvcMatchers(HttpMethod.GET, "/api/admin/user").hasRole("ADMINISTRATOR")
                   .mvcMatchers(HttpMethod.DELETE, "/api/admin/user/{email}").hasRole("ADMINISTRATOR")
                   .mvcMatchers(HttpMethod.PUT, "/api/admin/user/role").hasRole("ADMINISTRATOR")
                   .mvcMatchers(HttpMethod.PUT, "/api/admin/user/access").hasRole("ADMINISTRATOR")
                   .mvcMatchers( "/api/admin/user").hasRole("ADMINISTRATOR")
                   .mvcMatchers(HttpMethod.GET, "/api/security/events").hasRole("AUDITOR")
                   .and()
                   .exceptionHandling().accessDeniedHandler(customAccessDeniedHandler)
                   // other matchers
                   .and()
                   .sessionManagement()
                   .sessionCreationPolicy(SessionCreationPolicy.STATELESS); // no session
       }
    }

  learner_created: true
- name: src/account/DataLoader.java
  visible: true
  text: |
    package account;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Component;

    @Component
    public class DataLoader {

        private GroupRepository groupRepository;

        @Autowired
        public DataLoader(GroupRepository groupRepository) {
            this.groupRepository = groupRepository;
            createRoles();
        }

        private void createRoles() {
            try {
                groupRepository.save(new Group("ROLE_ADMINISTRATOR", "Administrator Group"));
                groupRepository.save(new Group("ROLE_USER", "User Group"));
                groupRepository.save(new Group("ROLE_ACCOUNTANT", "Accountant Group"));
                groupRepository.save(new Group("ROLE_AUDITOR", "Auditor Group"));
            } catch (Exception e) {

            }
        }
    }
  learner_created: true
- name: src/account/EventEnum.java
  visible: true
  text: "package account;\n\npublic enum EventEnum {\n    CREATE_USER (\"A user has\
    \ been successfully registered\"),\n    CHANGE_PASSWORD (\"A user has changed\
    \ the password successfully\"),\n    ACCESS_DENIED(\"A user is trying to access\
    \ a resource without access rights\t\"),\n    LOGIN_FAILED(\"Failed authentication\"\
    ),\n    GRANT_ROLE(\"A role is granted to a user\"),\n    REMOVE_ROLE(\"A role\
    \ has been revoked\"),\n    LOCK_USER(\"The Administrator has locked the user\"\
    ),\n    UNLOCK_USER(\"The Administrator has unlocked a user\"),\n    DELETE_USER(\"\
    The Administrator has deleted a user\"),\n    BRUTE_FORCE(\"A user has been blocked\
    \ on suspicion of a brute force attack\");\n\n\n\n    private String description\
    \ = null;\n\n    private EventEnum(String desc){\n        this.description = desc;\n\
    \    }\n\n    public String getDescription() {\n        return this.description;\n\
    \    }\n}\n"
  learner_created: true
- name: src/account/AuthenticationSuccessEventListener.java
  visible: true
  text: |
    package account;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.ApplicationListener;
    import org.springframework.security.authentication.event.AuthenticationSuccessEvent;
    import org.springframework.stereotype.Component;

    import javax.servlet.http.HttpServletRequest;

    @Component
    public class AuthenticationSuccessEventListener implements
            ApplicationListener<AuthenticationSuccessEvent> {

        @Autowired
        private HttpServletRequest request;

        @Autowired
        private LoginAttemptService loginAttemptService;

        @Override
        public void onApplicationEvent(final AuthenticationSuccessEvent e) {
            final String xfHeader = request.getHeader("X-Forwarded-For");
            /**if (xfHeader == null) {
                loginAttemptService.loginSucceeded(request.getRemoteAddr());
            } else {
                loginAttemptService.loginSucceeded(xfHeader.split(",")[0]);
            }*/

            Object user = e.getAuthentication().getPrincipal();
            Object credentials = e.getAuthentication().getCredentials();
            System.out.println("Successful login using USERNAME " + user);
            System.out.println("Successful login using PASSWORD " + credentials);
            UserDetailsImpl ud = (UserDetailsImpl) user;
            String email = ud.getUser().getEmail();
            loginAttemptService.loginSucceeded(email.toLowerCase());
        }
    }
  learner_created: true
- name: src/account/H2DAOFactory.java
  visible: true
  text: |
    package account;

    // Cloudscape concrete DAO Factory implementation
    import java.sql.*;

    public class H2DAOFactory extends DAOFactory {
        public static final String DRIVER=
                "org.h2.Driver";
        public static final String DBURL=
                "jdbc:h2:file:../service_db";

        // method to create Cloudscape connections
        public static Connection createConnection() throws SQLException, ClassNotFoundException {
            // Use DRIVER and DBURL to create a connection
            // Recommend connection pool implementation/usage
            Class.forName(DRIVER);
            return DriverManager.getConnection (DBURL, "sa","");
        }
        public PaymentDAO getPaymentDAO() {
            // H2PaymentsDAO implements PaymentsDAO
            return new H2PaymentDAO();
        }
    }
  learner_created: true
- name: src/account/PaymentDAO.java
  visible: true
  text: |
    package account;

    import javax.sql.RowSet;
    import java.util.ArrayList;
    import java.util.Collection;

    // Interface that all CustomerDAOs must support
    public interface PaymentDAO {
        public int insertPayment(Payment payment);
        public int insertPayments(Collection<Payment> payments);
        public int updatePayment(Payment payment);
        public RowSet selectPaymentsRS(String email);
        public ArrayList selectPaymentsTO(String email);
        public RowSet selectPaymentsForRS(String email, String date);
        public ArrayList selectPaymentsForTO(String email, String date);
    }
  learner_created: true
- name: src/account/Views.java
  visible: true
  text: |
    package account;

    public class Views {
        public static class Create {
        }
    }
  learner_created: true
- name: src/account/BCryptEncoderConfig.java
  visible: true
  text: |
    package account;

    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
    import org.springframework.security.crypto.password.PasswordEncoder;

    @Configuration
    public class BCryptEncoderConfig {

        @Bean
        public PasswordEncoder getEncoder() {
            return new BCryptPasswordEncoder();
        }
    }
  learner_created: true
- name: src/account/AuthenticationFailureListener.java
  visible: true
  text: |-
    package account;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.ApplicationListener;
    import org.springframework.security.authentication.event.AuthenticationFailureBadCredentialsEvent;
    import org.springframework.security.core.Authentication;
    import org.springframework.security.core.context.SecurityContextHolder;
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.stereotype.Component;

    import javax.servlet.http.HttpServletRequest;

    @Component
    public class AuthenticationFailureListener implements
            ApplicationListener<AuthenticationFailureBadCredentialsEvent> {

        @Autowired
        private HttpServletRequest request;

        @Autowired
        private LoginAttemptService loginAttemptService;

        @Autowired
        private EventRepository eventRepo;

        @Autowired
        private UserRepository userRepo;

        @Autowired
        private LockedAccounts lockedAccounts;

        @Override
        public void onApplicationEvent(AuthenticationFailureBadCredentialsEvent e) {
            final String xfHeader = request.getHeader("X-Forwarded-For");
            Object userName = e.getAuthentication().getPrincipal();
            Object credentials = e.getAuthentication().getCredentials();
            System.out.println("Failed login using USERNAME " + userName);
            System.out.println("Failed login using PASSWORD " + credentials);
            String email = (String) userName;
            Event event = new Event();
            String path = request.getRequestURI();
            event.setSubject(email.toLowerCase());
            event.setPath(path);
            event.setAction(EventEnum.LOGIN_FAILED.name());
            event.setObject(path);
            eventRepo.save(event);
            if (!userRepo.isAdmin(email)) {
                loginAttemptService.loginFailed(email.toLowerCase());
            }
            if(loginAttemptService.isBlocked(email.toLowerCase())){
                Event event1 = new Event();
                event1.setPath(path);
                event1.setSubject(email.toLowerCase());
                event1.setObject(path);
                event1.setAction(EventEnum.BRUTE_FORCE.name());
                eventRepo.save(event1);
                Event event2 = new Event();
                event2.setPath(path);
                event2.setSubject(email.toLowerCase());
                event2.setAction(EventEnum.LOCK_USER.name());
                event2.setObject("Lock user "+email);
                eventRepo.save(event2);
                lockedAccounts.lockUser(email);
            }

            /**if (xfHeader == null) {
                loginAttemptService.loginFailed(request.getRemoteAddr());
            } else {
                loginAttemptService.loginFailed(xfHeader.split(",")[0]);
            }*/
        }
    }
  learner_created: true
- name: src/account/UserDetailsImpl.java
  visible: true
  text: |+
    package account;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.security.core.GrantedAuthority;
    import org.springframework.security.core.authority.SimpleGrantedAuthority;
    import org.springframework.security.core.userdetails.UserDetails;

    import javax.transaction.Transactional;
    import java.util.*;

    public class UserDetailsImpl implements UserDetails {
        private final String username;
        private final String password;
        private final User user;
        //private final List<GrantedAuthority> rolesAndAuthorities;

        public UserDetailsImpl(User user) {
            username = user.getEmail();
            password = user.getPassword();
            this.user = user;
            //rolesAndAuthorities = List.of(new SimpleGrantedAuthority(""));
        }

        public User getUser() {
            return user;
        }

        @Override
        public Collection<? extends GrantedAuthority> getAuthorities() {
            //return rolesAndAuthorities;
            //return Collections.emptyList();
            Set<Group> userGroups = user.getUserGroups();
            Collection<GrantedAuthority> authorities = new ArrayList<>(userGroups.size());
            for(Group userGroup : userGroups){
                authorities.add(new SimpleGrantedAuthority(userGroup.getCode().toUpperCase()));
            }

            return authorities;
        }

        @Override
        public String getPassword() {
            return password;
        }

        @Override
        public String getUsername() {
            return username;
        }

        // 4 remaining methods that just return true
        @Override
        public boolean isAccountNonExpired() {
            return true;
        }

        @Override
        public boolean isAccountNonLocked() {
            return !user.getLocked();
        }

        @Override
        public boolean isCredentialsNonExpired() {
            return true;
        }

        @Override
        public boolean isEnabled() {
            return true;
        }
    }

  learner_created: true
- name: src/account/UserExistException.java
  visible: true
  text: |
    package account;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "User exist!")
    public class UserExistException extends RuntimeException {
        public UserExistException(String cause) {
            super(cause);
        }
    }
  learner_created: true
- name: src/account/CustomAuthenticationFailureHandler.java
  visible: true
  text: |
    package account;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.MessageSource;
    import org.springframework.security.core.AuthenticationException;
    import org.springframework.security.core.context.SecurityContextHolder;
    import org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler;
    import org.springframework.stereotype.Component;

    import javax.servlet.ServletException;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    import java.util.Locale;

    @Component
    public class CustomAuthenticationFailureHandler extends SimpleUrlAuthenticationFailureHandler {

        @Autowired
        private MessageSource messages;

        @Autowired
        private EventRepository eventRepo;

        @Override
        public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
            super.onAuthenticationFailure(request, response, exception);
            String errorMessage = messages.getMessage("message.badCredentials", null, Locale.ENGLISH);

            UserDetailsImpl details = (UserDetailsImpl) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
            if(details != null) {
                User user = details.getUser();
                Event event = new Event();
                String path = request.getRequestURI();
                event.setSubject(user.getEmail().toLowerCase());
                event.setPath(path);
                event.setAction(EventEnum.LOGIN_FAILED.name());
                event.setObject(path);
                eventRepo.save(event);
            }

            if (exception.getMessage().equalsIgnoreCase("blocked")) {
                if(details != null) {
                    User user = details.getUser();
                    Event event = new Event();
                    String path = request.getRequestURI();
                    event.setSubject(user.getEmail().toLowerCase());
                    event.setPath(path);
                    event.setAction(EventEnum.BRUTE_FORCE.name());
                    event.setObject(path);
                    eventRepo.save(event);
                }
                errorMessage = messages.getMessage("auth.message.blocked", null, Locale.ENGLISH);
            }
        }
    }
  learner_created: true
- name: src/account/BusinessController.java
  visible: true
  text: |
    package account;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.security.core.annotation.AuthenticationPrincipal;
    import org.springframework.web.bind.annotation.*;
    import org.springframework.web.server.ResponseStatusException;

    import java.text.DateFormatSymbols;
    import java.util.ArrayList;
    import java.util.Collection;
    import java.util.Map;

    @RestController
    public class BusinessController {

        @Autowired
        SqlitePaymentDAO sqlitePaymentDAO;

        @Autowired
        UserRepository userRepo;

        @GetMapping("api/empl/payment")
        public ResponseEntity<Object> getPayrolls(@AuthenticationPrincipal UserDetailsImpl details, @RequestParam(required = false) String period) {
            if (details == null) {
                return new ResponseEntity<>(Map.of("error", "email not valid"), HttpStatus.BAD_REQUEST);
            } else {
                System.out.println("PERIOD "+period);

                User user = details.getUser();
                ArrayList<Payment> collection;
                ArrayList col = new ArrayList<>();

                if (period == null) {
                    collection = sqlitePaymentDAO.selectPaymentsTO(user.getEmail());
                    for (Payment p : collection) {
                        String[] dateStr = p.getPeriod().split("-");
                        int i = Integer.parseInt(dateStr[0]);
                        String monthString = new DateFormatSymbols().getMonths()[i-1];

                        long dollars = p.getSalary()/100;
                        long cents = p.getSalary() % 100;

                        col.add(Map.of(
                                "name", user.getName(),
                                "lastname", user.getLastname(),
                                "period", monthString+"-"+dateStr[1],
                                "salary", dollars + " dollar(s) " + cents + " cent(s)"
                        ));
                    }
                    return new ResponseEntity<>(col, HttpStatus.OK);
                }
                if (!period.matches("(0[1-9]|1[0-2])-20[0-9]{2}$")){
                    return new ResponseEntity<>(Map.of("error", "Bad Request", "status", 400, "path", "/api/empl/payment"), HttpStatus.BAD_REQUEST);
                }
                collection = sqlitePaymentDAO.selectPaymentsForTO(user.getEmail(), period);
                if (collection.size() > 0) {
                    Payment p = collection.get(0);
                    String[] dateStr = p.getPeriod().split("-");
                    int i = Integer.parseInt(dateStr[0]);
                    String monthString = new DateFormatSymbols().getMonths()[i-1];
                    long dollars = p.getSalary()/100;
                    long cents = p.getSalary() % 100;
                    return new ResponseEntity<>(  Map.of(
                            "name", user.getName(),
                            "lastname", user.getLastname(),
                            "period", monthString+"-"+dateStr[1],
                            "salary", dollars + " dollar(s) " + cents + " cent(s)"
                    ), HttpStatus.OK);
                }
                return new ResponseEntity<>(  Map.of(), HttpStatus.OK);
                //return new ResponseEntity<>(Map.of("id", user.getId(), "name", user.getName(), "lastname", user.getLastname(), "email", user.getEmail()), HttpStatus.OK);
            }
        }

        @PostMapping("api/acct/payments")
        public Object addPayrolls(@RequestBody Collection<Payment> payments) {

            int i = sqlitePaymentDAO.insertPayments(payments);
            System.out.println(i);
            if (i == 1) {
                return new ResponseEntity<>(Map.of("status", "Added successfully!"), HttpStatus.OK);
            }
            return new ResponseEntity<>(Map.of("message", "payments[0].salary: Salary must be non negative!, payments[1].period: Wrong date!", "error","Bad Request","status", 400, "path", "/api/acct/payments"), HttpStatus.BAD_REQUEST);
        }

        @PutMapping("api/acct/payments")
        public Object updatePayrolls(@RequestBody Payment payment) {
            if (payment.getSalary() < 0) {
                return new ResponseEntity<>(Map.of("error", "Bad Request", "status", 400, "path", "/api/acct/payments"), HttpStatus.BAD_REQUEST);
            }
            if (!payment.getPeriod().matches("(0[1-9]|1[0-2])-20[0-9]{2}$")){
                return new ResponseEntity<>(Map.of("error", "Bad Request", "status", 400, "path", "/api/acct/payments"), HttpStatus.BAD_REQUEST);
            }
            if (!userRepo.hasUser(payment.getEmployee())) {
                return new ResponseEntity<>(Map.of("error", "Bad Request", "status", 400, "path", "/api/acct/payments"), HttpStatus.BAD_REQUEST);
            }
            int i = sqlitePaymentDAO.updatePayment(payment);
            return new ResponseEntity<>(Map.of("status", "Updated successfully!"), HttpStatus.OK);
        }
    }
  learner_created: true
- name: src/account/Key.java
  visible: true
  text: |
    package account;

    import javax.validation.constraints.NotEmpty;

    public class Key {
        @NotEmpty
        private String user;
        private String operation;

        public Key() {}

        public String getUser() {
            return user;
        }

        public void setUser(String user) {
            this.user = user;
        }

        public String getOperation() {
            return operation;
        }

        public void setOperation(String operation) {
            this.operation = operation;
        }
    }
  learner_created: true
- name: src/account/User.java
  visible: true
  text: |
    package account;

    import com.fasterxml.jackson.annotation.JsonView;
    import org.springframework.stereotype.Service;

    import javax.persistence.*;
    import javax.validation.constraints.Size;
    import java.util.HashSet;
    import java.util.Set;

    @Entity
    @Table(name = "user")
    public class User {
        @Column
        private String name;
        @Column
        private String lastname;
        @Column
        private String email;
        @Column
        @Size(min = 12, message = "The password length must be at least 12 chars!")
        private String password;
        @Column(columnDefinition = "boolean default false")
        private Boolean locked;
        @Column
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;

        public User(String name, String lastname, String email, String password) {
            this.name = name;
            this.lastname = lastname;
            this.email = email;
            this.password = password;
        }

        public User() {
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getLastname() {
            return lastname;
        }

        public void setLastname(String lastname) {
            this.lastname = lastname;
        }

        public String getEmail() {
            return email;
        }

        public void setEmail(String email) {
            this.email = email;
        }

        public String getPassword() {
            return password;
        }

        public void setPassword(String password) {
            this.password = password;
        }

        public void setId(Long id) {
            this.id = id;
        }

        public Long getId() {
            return id;
        }

        @ManyToMany(cascade = {
                CascadeType.PERSIST,
                CascadeType.MERGE
        }, fetch = FetchType.EAGER)
        @JoinTable(name = "user_groups",
                joinColumns =@JoinColumn(name = "user_id"),
                inverseJoinColumns = @JoinColumn(name = "group_id"
                ))
        private Set<Group> userGroups= new HashSet<>();

        public Set<Group> getUserGroups() {
            return userGroups;
        }

        public Boolean getLocked() {
            return locked;
        }

        public void setLocked(Boolean locked) {
            this.locked = locked;
        }

        public void setUserGroups(Set<Group> userGroups) {
            this.userGroups = userGroups;
        }

        public void addUserGroups(Group group) {
            userGroups.add(group);
        }

        public void removeUserGroups(Group group) {
            userGroups.remove(group);
        }

        @Override
        public String toString() {
            return "User{" +
                    "name='" + name + '\'' +
                    ", email='" + email + '\'' +
                    '}';
        }

    }
  learner_created: true
- name: src/account/EventRepository.java
  visible: true
  text: |
    package account;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Component;

    import java.awt.desktop.UserSessionEvent;
    import java.util.ArrayList;
    import java.util.List;

    @Component
    public class EventRepository {

        @Autowired
        EventIRepository eventIRepo;

        public Object getEvents() {
            //return  events;
            List<Event> eventList = new ArrayList<>();
            eventIRepo.findAll().forEach(event -> eventList.add(event));
            return eventList;
        }

        public void save(Event event) {
            //saves an event
            Event savedEvent = eventIRepo.save(event);
            System.out.println(savedEvent + " saved.");
        }
    }
  learner_created: true
- name: src/account/Role.java
  visible: true
  text: |
    package account;

    import javax.validation.constraints.NotEmpty;
    import javax.validation.constraints.NotNull;

    public class Role {
        @NotEmpty
        private String user;
        private String role;
        private String operation;

        public Role() {
        }

        public String getUser() {
            return user;
        }

        public void setUser(String user) {
            this.user = user;
        }

        public String getRole() {
            return role;
        }

        public void setRole(String role) {
            this.role = role;
        }

        public String getOperation() {
            return operation;
        }

        public void setOperation(String operation) {
            this.operation = operation;
        }
    }
  learner_created: true
- name: src/account/CommandRunner.java
  visible: true
  text: |
    package account;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.CommandLineRunner;
    import org.springframework.stereotype.Component;

    @Component
    class CommandRunner implements CommandLineRunner {

        @Autowired
        private UserRepository userRepository;

        @Autowired
        private BCryptEncoderConfig b;

        @Override
        public void run(String... args) throws Exception {


            User user = new User();
            user.setId(88L);
            user.setName("Abdulmumin");
            user.setLastname("Abdulkarim");
            user.setEmail("user@acme.com");
            user.setPassword(b.getEncoder().encode("password"));
            System.out.println("Encoded password "+user.getPassword());
            //userRepository.save(user);
        }
    }
  learner_created: true
- name: src/account/Group.java
  visible: true
  text: |
    package account;

    import javax.persistence.*;
    import java.util.Set;

    @Entity
    @Table(name = "principle_groups")
    public class Group{

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;

        @Column(unique = true, nullable = false)
        private String code;
        private String name;

        public Group() {
        }

        public Group(String code, String name) {
            this.code = code;
            this.name = name;
        }

        public Long getId() {
            return id;
        }

        public void setId(Long id) {
            this.id = id;
        }

        public String getCode() {
            return code;
        }

        public void setCode(String code) {
            this.code = code;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        @Override
        public String toString() {
            return "Group{" +
                    "code='" + code + '\'' +
                    ", name='" + name + '\'' +
                    '}';
        }

        @ManyToMany(mappedBy = "userGroups", fetch = FetchType.EAGER )
        private Set<User> users;
    }
  learner_created: true
- name: src/account/Password.java
  visible: true
  text: |
    package account;

    import javax.validation.constraints.Size;

    public class Password {
        @Size(min = 12, message = "The password length must be at least 12 chars!")
        private String new_password;

        public String getNew_password() {
            return new_password;
        }

        public void setNew_password(String new_password) {
            this.new_password = new_password;
        }
    }
  learner_created: true
- name: src/account/Event.java
  visible: true
  text: |
    package account;

    import javax.persistence.*;
    import java.util.Date;

    @Entity
    @Table(name = "event")
    public class Event {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
        @Temporal(TemporalType.TIMESTAMP)
        @Column(nullable = false)
        private Date date;
        private String action;
        private String subject;
        private String object;
        private String path;

        public Event() {}

        public Long getId() {
            return id;
        }

        public void setId(Long id) {
            this.id = id;
        }

        public Date getDate() {
            return date;
        }

        public void setDate(Date date) {
            this.date = date;
        }

        public String getAction() {
            return action;
        }

        public void setAction(String action) {
            this.action = action;
        }

        public String getSubject() {
            return subject;
        }

        public void setSubject(String subject) {
            this.subject = subject;
        }

        public String getObject() {
            return object;
        }

        public void setObject(String object) {
            this.object = object;
        }

        public String getPath() {
            return path;
        }

        public void setPath(String path) {
            this.path = path;
        }

        @PrePersist
        private void onCreate() {
            date = new Date();
        }
    }
  learner_created: true
- name: src/account/UserRepository.java
  visible: true
  text: |
    package account;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Component;

    import java.util.*;
    import java.util.concurrent.ConcurrentHashMap;

    @Component
    public class UserRepository{
        final private Map<String, User> users = new ConcurrentHashMap<>();

        @Autowired
        UsersRepository repository;

        @Autowired
        GroupRepository groupRepository;


        public User findUserByEmail(String email) {
            List<User> list = new ArrayList<>();
            repository.findAll().forEach(user -> list.add(user));

            Optional<User> matchingUser = list.stream().
                    filter(u -> u.getEmail().equalsIgnoreCase(email)).
                    findFirst();
            User user = null;
            if (matchingUser.isPresent()){
                user = matchingUser.get();
                user.setEmail(email);
            }
            //return matchingUser.orElse(null);
            return user;
        }

        public User findUserByID(long id) {
            return repository.findById(id).get();
        }

        public void save(User user) {
            //users.put(user.getEmail(), user);
            updateUserGroup(user);
            User savedUser = repository.save(user);
            System.out.println(savedUser + " saved.");
        }

        public User update(User user) {
            User updatedUser = repository.save(user);
            System.out.println(updatedUser + " updated.");
            return updatedUser;
        }

        public void delete(User user) {
            //users.put(user.getEmail(), user);
            repository.delete(user);
            System.out.println(user + " deleted.");
        }

        public void updatePassword(User user) {
            //users.put(user.getEmail(), user);
            User savedUser = repository.save(user);
            System.out.println(savedUser + " saved.");
        }

        public User updateRole(User user) {
            User updatedUser = repository.save(user);
            System.out.println(updatedUser + " updated.");
            return updatedUser;
        }

        public boolean hasUser(User user) {
            //return users.containsKey(user.getEmail());
            List<User> list = new ArrayList<>();
            repository.findAll().forEach(us -> list.add(us));

            Optional<User> matchingUser = list.stream().
                    filter(u -> u.getEmail().equalsIgnoreCase(user.getEmail())).
                    findFirst();

            return matchingUser.isPresent();
        }


        public boolean hasUser(String email) {
            //return users.containsKey(user.getEmail());
            List<User> list = new ArrayList<>();
            repository.findAll().forEach(us -> list.add(us));

            Optional<User> matchingUser = list.stream().
                    filter(u -> u.getEmail().equalsIgnoreCase(email)).
                    findFirst();

            return matchingUser.isPresent();
        }

        public boolean hasAdmin() {
            //return users.containsKey(user.getEmail());
            List<User> list = new ArrayList<>();
            repository.findAll().forEach(us -> list.add(us));
    System.out.println("1oo");
    if(list.size()<=0){
        return false;
    }
            Iterator i = list.iterator();
            while(i.hasNext()){
                System.out.println("2");
                User u = (User) i.next();
                Set<Group> groups = u.getUserGroups();
                Iterator setI = groups.iterator();
                while(setI.hasNext()){
                    System.out.println("3");
                    Group g = (Group) setI.next();
                    if (g.getCode().equalsIgnoreCase("ROLE_ADMINISTRATOR")){
                        return true;
                    }
                }
                System.out.println("4");
            }
            return false;
        }

        public boolean isAdmin(String email) {

            List<User> list = new ArrayList<>();
            repository.findAll().forEach(us -> list.add(us));
            System.out.println("2oo");
            if(list.size()<=0){
                return false;
            }
            Iterator i = list.iterator();
            while(i.hasNext()) {
                System.out.println("22");
                User u = (User) i.next();
                if (u.getEmail().equalsIgnoreCase(email)) {
                    Set<Group> groups = u.getUserGroups();
                    Iterator setI = groups.iterator();
                    while (setI.hasNext()) {
                        System.out.println("33");
                        Group g = (Group) setI.next();
                        if (g.getCode().equalsIgnoreCase("ROLE_ADMINISTRATOR")) {
                            return true;
                        }
                    }
                    System.out.println("44");
                }
            }
            return false;
        }

        public Object getUsers() {
            //return  users;
            List<User> us = new ArrayList<>();
            repository.findAll().forEach(user -> us.add(user));
            return us;
        }

        private void updateUserGroup(User user){
            Group group = null;
            if (hasAdmin()) {
                group = groupRepository.findByCode("ROLE_USER");
                user.addUserGroups(group);
            } else {
                group = groupRepository.findByCode("ROLE_ADMINISTRATOR");
                user.addUserGroups(group);
            }
        }


    }
  learner_created: true
- name: src/resources/keystore/keystore.p12
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/16607#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">JetBrains
    Academy</a> to continue learning.
  time: Thu, 03 Feb 2022 10:29:52 UTC
record: -1
